#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Simple Tkinter GUI to run the full Intan -> sorting -> PDF pipeline.

This script lets a user fill all required inputs from a form instead of
editing the main Python script manually.

High-level behavior:
  - Collect runtime paths and processing parameters from the user.
  - Run the full pipeline in a background worker thread.
  - Keep all Tkinter UI updates on the main thread (thread-safe).
  - Show progress and errors in a log panel.
"""

import os
import json
import time
import ctypes
import threading
import traceback
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog, messagebox
from tkinter.scrolledtext import ScrolledText

from TriggerClass import Trigger
from TimestampsClass import TimestampsParameters
from SorterClass import Sorter
from ProtocolClass import Protocol
from IntanClass import IntanFile
from ProbeClass import Probe
from PipelineClass import Pipeline
from PDFGeneratorClass import PDFGenerator


class PipelineGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("SpikeSorting Pipeline Launcher")
        self.geometry("960x680")
        self._session_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "gui_last_session.json")

        # Form fields (StringVar) bound to GUI entries.
        self.folder_path_var = tk.StringVar()
        self.use_trigger_var = tk.BooleanVar(value=True)
        self.trigger_threshold_var = tk.StringVar(value="37000")
        self.trigger_edge_var = tk.StringVar(value="-1")
        self.trigger_min_interval_var = tk.StringVar(value="5.1")
        self.trigger_channel_index_var = tk.StringVar(value="0")
        self.sorter_name_var = tk.StringVar(value="tridesclous2")
        self.my_protocol_filename_var = tk.StringVar(value="my_protocol.json")
        self.my_probe_path_var = tk.StringVar(value="C:/Spikesorting_utilities/MEA_RdLGN64.json")
        self.min_freq_var = tk.StringVar(value="400")
        self.max_freq_var = tk.StringVar(value="5000")
        # Keep references to trigger widgets so we can gray/enable them from checkbox state.
        self._trigger_widgets = []
        self._load_last_session()

        self._build_form()
        self.protocol("WM_DELETE_WINDOW", self._on_close)

    def _build_form(self):
        # Main container for all controls.
        container = tk.Frame(self)
        container.pack(fill="both", expand=True, padx=12, pady=12)

        row = 0
        # folder_path: Intan recording folder (and output folder).
        self._add_labeled_path(
            container,
            row,
            "Intan_files_folder_path",
            self.folder_path_var,
            browse_mode="folder",
        )
        row += 1
        # Optional trigger extraction.
        tk.Checkbutton(
            container,
            text="Use trigger detection",
            variable=self.use_trigger_var,
            onvalue=True,
            offvalue=False,
            # When toggled, immediately refresh the visual state of trigger fields.
            command=self._toggle_trigger_fields_state,
        ).grid(row=row, column=0, columnspan=2, sticky="w", pady=4)
        row += 1
        # Trigger/timestamp settings.
        self._trigger_widgets.extend(
            self._add_labeled_entry(container, row, "trigger.threshold", self.trigger_threshold_var)
        )
        row += 1
        self._trigger_widgets.extend(
            self._add_labeled_entry(container, row, "trigger.edge (-1 or 1)", self.trigger_edge_var)
        )
        row += 1
        self._trigger_widgets.extend(
            self._add_labeled_entry(container, row, "trigger.min_interval (s)", self.trigger_min_interval_var)
        )
        row += 1
        self._trigger_widgets.extend(
            self._add_labeled_entry(container, row, "trigger_channel_index", self.trigger_channel_index_var)
        )
        row += 1
        # Sorter name recognized by spikeinterface.sorters.
        self._add_labeled_entry(container, row, "sorter_name", self.sorter_name_var)
        row += 1
        # Protocol file is saved inside folder_path.
        self._add_labeled_entry(container, row, "my_protocol filename (.json)", self.my_protocol_filename_var)
        row += 1
        # Probe file path (.json generated by probeinterface).
        self._add_labeled_path(
            container,
            row,
            "my_probe_df path (.json)",
            self.my_probe_path_var,
            browse_mode="file",
            file_types=[("JSON files", "*.json"), ("All files", "*.*")],
        )
        row += 1
        # Band-pass boundaries for Protocol.
        self._add_labeled_entry(container, row, "protocol min_freq", self.min_freq_var)
        row += 1
        self._add_labeled_entry(container, row, "protocol max_freq", self.max_freq_var)
        row += 1

        controls = tk.Frame(container)
        controls.grid(row=row, column=0, columnspan=3, sticky="w", pady=(10, 6))

        self._run_button = tk.Button(controls, text="Run Pipeline", command=self._run_pipeline_async, width=18)
        self._run_button.pack(side="left")

        clear_button = tk.Button(controls, text="Clear Logs", command=self._clear_logs, width=18)
        clear_button.pack(side="left", padx=(8, 0))

        row += 1
        tk.Label(container, text="Logs").grid(row=row, column=0, sticky="w", pady=(8, 4))
        row += 1

        # Indeterminate bar = visual activity during long sorter stage.
        self._progressbar = ttk.Progressbar(container, mode="indeterminate")
        self._progressbar.grid(row=row, column=0, columnspan=3, sticky="ew", pady=(0, 8))
        row += 1

        self.logs = ScrolledText(container, height=20, wrap="word")
        self.logs.grid(row=row, column=0, columnspan=3, sticky="nsew")

        container.columnconfigure(1, weight=1)
        container.rowconfigure(row, weight=1)
        self._toggle_trigger_fields_state()

    def _add_labeled_entry(self, parent, row, label, text_var):
        """Create one label + text entry row."""
        label_widget = tk.Label(parent, text=label)
        label_widget.grid(row=row, column=0, sticky="w", pady=4)
        entry = tk.Entry(parent, textvariable=text_var, width=90)
        entry.grid(row=row, column=1, sticky="ew", pady=4)
        return [label_widget, entry]

    def _toggle_trigger_fields_state(self):
        """Enable/disable trigger parameter fields from checkbox state."""
        is_enabled = bool(self.use_trigger_var.get())
        entry_state = tk.NORMAL if is_enabled else tk.DISABLED
        label_color = "black" if is_enabled else "gray50"
        # Entries are disabled (grayed) when trigger is off to make intent explicit.
        for widget in self._trigger_widgets:
            if isinstance(widget, tk.Entry):
                widget.config(state=entry_state)
            elif isinstance(widget, tk.Label):
                widget.config(fg=label_color)

    def _collect_form_state(self):
        """Collect current form values for persistence."""
        return {
            "folder_path": self.folder_path_var.get(),
            "use_trigger": bool(self.use_trigger_var.get()),
            "trigger_threshold": self.trigger_threshold_var.get(),
            "trigger_edge": self.trigger_edge_var.get(),
            "trigger_min_interval": self.trigger_min_interval_var.get(),
            "trigger_channel_index": self.trigger_channel_index_var.get(),
            "sorter_name": self.sorter_name_var.get(),
            "my_protocol_filename": self.my_protocol_filename_var.get(),
            "my_probe_path": self.my_probe_path_var.get(),
            "min_freq": self.min_freq_var.get(),
            "max_freq": self.max_freq_var.get(),
        }

    def _apply_form_state(self, state):
        """Apply persisted form values when available."""
        if not isinstance(state, dict):
            return
        self.folder_path_var.set(state.get("folder_path", self.folder_path_var.get()))
        self.use_trigger_var.set(bool(state.get("use_trigger", self.use_trigger_var.get())))
        self.trigger_threshold_var.set(state.get("trigger_threshold", self.trigger_threshold_var.get()))
        self.trigger_edge_var.set(state.get("trigger_edge", self.trigger_edge_var.get()))
        self.trigger_min_interval_var.set(state.get("trigger_min_interval", self.trigger_min_interval_var.get()))
        self.trigger_channel_index_var.set(state.get("trigger_channel_index", self.trigger_channel_index_var.get()))
        self.sorter_name_var.set(state.get("sorter_name", self.sorter_name_var.get()))
        self.my_protocol_filename_var.set(state.get("my_protocol_filename", self.my_protocol_filename_var.get()))
        self.my_probe_path_var.set(state.get("my_probe_path", self.my_probe_path_var.get()))
        self.min_freq_var.set(state.get("min_freq", self.min_freq_var.get()))
        self.max_freq_var.set(state.get("max_freq", self.max_freq_var.get()))

    def _load_last_session(self):
        """Load last GUI form values from disk."""
        if not os.path.isfile(self._session_file):
            return
        try:
            with open(self._session_file, "r", encoding="utf-8") as f:
                self._apply_form_state(json.load(f))
        except Exception:
            # Keep defaults if session file is invalid/unreadable.
            pass

    def _save_last_session(self):
        """Persist current form values to disk."""
        try:
            with open(self._session_file, "w", encoding="utf-8") as f:
                json.dump(self._collect_form_state(), f, indent=2, ensure_ascii=True)
        except Exception:
            # Persistence failure must never block pipeline execution.
            pass

    def _on_close(self):
        """Save form state before closing the window."""
        self._save_last_session()
        self.destroy()

    def _add_labeled_path(self, parent, row, label, text_var, browse_mode, file_types=None):
        """Create one path row with a Browse button."""
        tk.Label(parent, text=label).grid(row=row, column=0, sticky="w", pady=4)
        entry = tk.Entry(parent, textvariable=text_var, width=90)
        entry.grid(row=row, column=1, sticky="ew", pady=4)

        button = tk.Button(
            parent,
            text="Browse",
            command=lambda: self._browse_path(text_var, browse_mode, file_types),
            width=10,
        )
        button.grid(row=row, column=2, sticky="w", padx=(8, 0), pady=4)

    def _browse_path(self, target_var, mode, file_types=None):
        """Open a file/folder dialog and write the selected path."""
        if mode == "folder":
            selected = filedialog.askdirectory()
        else:
            selected = filedialog.askopenfilename(filetypes=file_types or [("All files", "*.*")])
        if selected:
            target_var.set(selected)
            self._save_last_session()

    def _clear_logs(self):
        """Clear the log output area."""
        self.logs.delete("1.0", tk.END)

    def _set_run_button_state(self, enabled):
        """Enable/disable the Run button safely from any thread."""
        if threading.current_thread() is threading.main_thread():
            self._run_button.config(state=tk.NORMAL if enabled else tk.DISABLED)
        else:
            # `after(0, ...)` schedules UI updates on Tkinter main thread.
            self.after(0, lambda: self._run_button.config(state=tk.NORMAL if enabled else tk.DISABLED))

    def _set_sorter_progress(self, running):
        """Start/stop sorter progress bar safely from any thread."""
        def _apply():
            # Indeterminate mode = unknown % completion, but confirms activity.
            if running:
                self._progressbar.start(10)
            else:
                self._progressbar.stop()

        if threading.current_thread() is threading.main_thread():
            _apply()
        else:
            self.after(0, _apply)

    def _open_output_folder(self, folder_path):
        """
        Open output folder in Explorer and try to bring it to front.
        """
        if os.path.isdir(folder_path):
            os.startfile(folder_path)
            time.sleep(0.25)
            user32 = ctypes.windll.user32
            hwnd = user32.FindWindowW("CabinetWClass", None)
            if hwnd:
                user32.ShowWindow(hwnd, 9)  # SW_RESTORE
                user32.SetForegroundWindow(hwnd)
        else:
            raise ValueError(f"Output folder not found: {folder_path}")

    def _log(self, message):
        """Append one line to logs (thread-safe)."""
        if threading.current_thread() is threading.main_thread():
            self.logs.insert(tk.END, message + "\n")
            self.logs.see(tk.END)
        else:
            self.after(0, lambda: self._log(message))

    def _show_info(self, title, message):
        """Display info dialog from main UI thread."""
        if threading.current_thread() is threading.main_thread():
            messagebox.showinfo(title, message)
        else:
            self.after(0, lambda: messagebox.showinfo(title, message))

    def _show_error(self, title, message):
        """Display error dialog from main UI thread."""
        if threading.current_thread() is threading.main_thread():
            messagebox.showerror(title, message)
        else:
            self.after(0, lambda: messagebox.showerror(title, message))

    def _on_pipeline_success(self, folder_path):
        """Final UI actions after successful run."""
        self._set_sorter_progress(False)
        self._log("Pipeline completed successfully.")
        self._log("Opening output folder...")
        self._open_output_folder(folder_path)
        self._show_info(
            "Done",
            "Pipeline completed successfully.\n\nOutput folder has been opened.",
        )

    def _run_pipeline_async(self):
        """Launch pipeline in background thread to keep UI responsive."""
        self._save_last_session()
        self._set_run_button_state(enabled=False)
        thread = threading.Thread(target=self._run_pipeline, daemon=True)
        thread.start()

    def _run_pipeline(self):
        """
        Validate inputs, run processing pipeline, and generate PDF report.
        """
        try:
            folder_path = self.folder_path_var.get().strip()
            use_trigger = bool(self.use_trigger_var.get())
            sorter_name = self.sorter_name_var.get().strip()
            my_protocol_filename = self.my_protocol_filename_var.get().strip()
            my_probe_path = self.my_probe_path_var.get().strip()
            min_freq = float(self.min_freq_var.get().strip())
            max_freq = float(self.max_freq_var.get().strip())
            trigger_threshold = None
            trigger_edge = None
            trigger_min_interval = None
            trigger_channel_index = None
            # Parse trigger parameters only when trigger mode is active.
            if use_trigger:
                trigger_threshold = float(self.trigger_threshold_var.get().strip())
                trigger_edge = int(self.trigger_edge_var.get().strip())
                trigger_min_interval = float(self.trigger_min_interval_var.get().strip())
                trigger_channel_index = int(self.trigger_channel_index_var.get().strip())

            if not folder_path or not os.path.isdir(folder_path):
                raise ValueError("folder_path is missing or does not exist.")
            if not my_protocol_filename:
                raise ValueError("my_protocol filename is required.")
            if not my_probe_path or not os.path.isfile(my_probe_path):
                raise ValueError("my_probe_df path is missing or does not exist.")
            if min_freq <= 0 or max_freq <= 0:
                raise ValueError("protocol min_freq and max_freq must be > 0.")
            if min_freq >= max_freq:
                raise ValueError("protocol min_freq must be < max_freq.")
            if use_trigger:
                if trigger_edge not in (-1, 1):
                    raise ValueError("trigger.edge must be -1 or 1.")
                if trigger_channel_index < 0:
                    raise ValueError("trigger_channel_index must be >= 0.")

            if not my_protocol_filename.lower().endswith(".json"):
                my_protocol_filename = f"{my_protocol_filename}.json"
            my_protocol_path = os.path.join(folder_path, my_protocol_filename)

            self._log("Starting pipeline...")
            self._log(f"folder_path: {folder_path}")
            self._log(f"sorter_name: {sorter_name}")
            self._log(f"use_trigger: {use_trigger}")
            if use_trigger:
                self._log(
                    f"trigger: threshold={trigger_threshold}, edge={trigger_edge}, min_interval={trigger_min_interval}"
                )
                self._log(f"trigger_channel_index: {trigger_channel_index}")
            self._log(f"protocol_path (auto): {my_protocol_path}")
            self._log(f"probe_path: {my_probe_path}")
            self._log(f"bandpass: {min_freq} -> {max_freq} Hz")

            # Build core objects and run the same flow as script mode.
            timestamps_parameters = None
            if use_trigger:
                # Trigger object is only needed for timestamp extraction path.
                trigger = Trigger(trigger_threshold, trigger_edge, trigger_min_interval)
                timestamps_parameters = TimestampsParameters(
                    trigger=trigger,
                    trigger_channel_index=trigger_channel_index,
                )
            sorter = Sorter(sorter_name)
            self._log("Loading Intan files...")
            rhs_files = IntanFile(folder_path)
            self._log(f"Channel IDs: {rhs_files.channel_ids}")
            self._log(f"Sampling frequency: {rhs_files.frequency}")
            self._log(f"Number of channels: {rhs_files.number_of_channels}")
            self._log(f"Number of segments: {rhs_files.number_of_segments}")
            if use_trigger:
                self._log("Computing trigger timestamps...")
                rhs_files.generate_trigger_timestamps(timestamps_parameters)
            else:
                # Keep pipeline fully valid without artifact timestamps.
                self._log("Trigger disabled: skipping trigger timestamp extraction.")

            protocol = Protocol(min_freq, max_freq, my_protocol_path)
            my_probe_df = Probe(my_probe_path)
            self._log("Associating probe...")
            rhs_files.associate_probe(my_probe_df)

            # Longest stage: keep progress bar running during sorter/analyzer.
            self._log("Running sorter + analyzer (this can take time)...")
            self._set_sorter_progress(True)
            pipeline = Pipeline(sorter, folder_path, protocol, rhs_files)
            self._set_sorter_progress(False)
            self._log("Generating PDF report...")
            PDFGenerator(folder_path, pipeline)

            self.after(0, lambda: self._on_pipeline_success(folder_path))

        except Exception as exc:
            self._set_sorter_progress(False)
            self._log(f"ERROR: {exc}")
            self._log(traceback.format_exc())
            self._show_error("Error", str(exc))
        finally:
            self._set_run_button_state(enabled=True)


if __name__ == "__main__":
    app = PipelineGUI()
    app.mainloop()
